---
layout: "default"
Category: "Story"
title: "코딩이 재미있는 이유"
description: '2019-10-13 '
---

&nbsp;&nbsp;&nbsp;&nbsp;가끔 사람들을 만나서, 내가 코딩 좋아한다고 하면 물어보는 말들이 있어.

"코딩 그거 재밌어? 어렵지 않아?"

&nbsp;&nbsp;&nbsp;&nbsp;그런 얘기를 들을 때 마다, 내가 하는 이야기를 들려줄게. 얘기가 너무 길어서, 사람들이 많은 술자리에선 잘 하지 않지만, 개인적으로 만나면 자주 하는 이야기야. 조금 오글거릴 수도 있어. 주의해서 들어줘.

&nbsp;&nbsp;&nbsp;&nbsp;자 생각을 해보자. 너는 이제부터 공주를 구하러 온 용사야. 그렇게 마왕의 성에 도착해서 막 들어가려고 하는 순간, 문 앞에 큰 용이 나타나서 말하는거야.

"지금부터 내가 내는 문제를 맞추면, 길을 비켜 주겠다."

&nbsp;&nbsp;&nbsp;&nbsp;당연히 너는 큰 용과 싸우는 것 보다, 문제를 맞추는 것이 더 쉽다고 판단했지. 그래서 문제를 들어 봤어.

~~~

무게와 모양이 같은 당구공이 7개가 있다.

그런데 이 당구공 중에서 딱 한개의 공이 다른 공들 보다 무게가 가볍다.

이때, 양팔 저울을 사용해서 무게가 가벼운 공을 찾아내려고 한다.

최소한의 횟수로 양팔저울을 사용한다고 할 때, 최소 몇번을 사용해야 할까?

(양팔저울에 대한 부연설명)
양팔저울을 사용하는 동안 공을 빼거나 집어넣는 행위는 할 수 없다.

양팔저울에 올려놓을 수 있는 공의 갯수는 정해지지 않았다.

만약 당구공 중 2개를 집어서 양팔저울 양쪽에 올려 놓았다고 할때, 운이 좋으면 저울이 기울어서 답을 바로 찾을 수도 있다는 것이다.

다만, 문제에서 필요로하는 최소한의 횟수란, 최악의 경우에서의 최소비교 횟수를 말한다.

~~~

이런 문제를 냈다고 생각해보자.

##### 잠깐 스크롤을 내리지 말고 문제를 풀어봐.

답을 알려줄게.

정답은 두번이야.

1.6개의 공을 집어서 저울에 3개씩 놓으면, 저울이 기울어지거나 평형이 유지되겠지? 평형이 유지된다면, 나머지 한개의 공이 가벼운 공이고. 평형이 깨진다면, 더 가벼운 쪽에 있는 3개의 공 중에 가벼운 공이 있겠지?

2.그 세개의 공 중에 두개의 공을 비교하면, 저울이 기울어 지거나 평행이 유지되겠지? 그러면, 이전 경우처럼 평형이 유지된다면, 나머지 한개의 공이 가벼운 공이고. 평형이 깨진다면 더 가벼운공이 우리가 찾던 공인거야.


&nbsp;&nbsp;&nbsp;&nbsp;어때? 생각보다 그렇게 어렵지는 않았지? 문제를 맞추고 공주를 구하러 가려고 하는 순간, 용이 말하는거야.

"사실 그 문제는 우리들 중 최약체였다."

너는 오기가 생겨버리는 거지. 그래서 좀 더 강한 문제를 용한테 요구한거야. 아래의 문제가 바로 다음 문제야.

~~~

A,B,C,D가 다리를 건너려고 한다.

다리는 한번에 두명만 건널 수 있고, 다리를 거너는 데에는 손전등이 필요하다.

그런데 손전등은 하나밖에 없다.

즉, 두명이 손전등을 들고 건너갔다가 그 중 한명은 손전등을 다시 들고 와서 나머지 사람들에게 전달해 줘야 하는 거야.

A,B,C,D는 각각 혼자서 다리를 건너는 데에 1분,2분,5분,10분이 걸린다.

그리고 두사람이 다리를 건너면, 시간이 더 오래걸리는 사람의 시간으로 계산한다.

예를들어, A와 D가 건너면, 다리를 건너는 데에 10분이 걸린다.

이때, 모두가 다리를 건너는 데에 필요한 최소시간은 몇분일까?

~~~


아까 문제 보다는 어려워 보이지? 한번 생각해봐!

&nbsp;&nbsp;&nbsp;&nbsp;내 생각에 너는 아마 19분이라고 생각했을거야. 그렇다면 한번 더 생각해 보길 바래. 너가 생각한 알고리즘은 아마 이럴거야. 제일 빠른 A가 손전등을 들고 왔다갔다 하는 걸 생각했지? 물론 직관적으로는 이게 빠르게 생각되지. 나쁘지 않은 알고리즘이야. 그런데 답은 17분이야. 다시한번 생각해봐.

설명해줄게.

처음에 AB가 같이 건너가 (2분)

A가 손전등을 들고 돌아와 (1분)

C와 D가 손전등을 들고 건너가 (10분)

B가 손전등을 들고 돌아와 (2분)

A,B가 건너가 (2분)

&nbsp;&nbsp;&nbsp;&nbsp;어때 17분이지? 처음 알고리즘을 짤 때는, 눈치채지 못했겠지만, 이 문제에는 숨겨진 비밀이 있어. 바로 두명이 같이 다리를 건너면, 더 빠른 사람이 다리를 건너는 시간이 더 느린 사람이 건너는 데에 필요한 시간에 뭍혀버린다는 거야. CD가 같이 건너면, 건너는 데에 5분이 걸리는 C의 시간이 D때문에 뭍혀버리는거지. 만약, 처음부터 이런 원리를 간파하고 17분이라는 답을 구해냈다면 너는 천재라고 할 수 있어. 다른사람은 몰라도 내가 그렇게 불러줄게.

&nbsp;&nbsp;&nbsp;&nbsp;그리곤 용이 말하는 거야. "여기까지 풀었다면 꽤나 머리가 좋은 용사군. 지나가는걸 허락하지." 그런데 너는 더더욱 오기가 생겨서 계속 문제를 물어보게 되는거야.

&nbsp;&nbsp;&nbsp;&nbsp;여기까지 문제를 풀었다면 왜 코딩이 재미있는지 조금은 이해했을 것이라 생각해. 앞의 두 문제의 본질을 생각해보자. 두 문제 전부 좀 더 빠르게, 효율적으로 문제를 푸는 것에 초점을 맞추고 있어. 그게 바로 코딩의 본질이야. 어떻게 하면 컴퓨터를 조금 덜 쓰면서 문제를 해결할 수 있을까를 끊임없이 고민하는 일이 프로그래머지. 결국 프로그래머는 하루 종일 과학동아에 나오는 퀴즈를 풀고있는 꼬마아이와 본질적으로 같다는거야. 이런 일이라면 평생 지루하지 않게 일을 할 수 있지 않을까? 이게 바로 코딩이 재밌는 이유야.

&nbsp;&nbsp;&nbsp;&nbsp;본문의 내용은 내가 오래전에 읽었던 책에 있었던 내용이야. 책의 이름은 기억나지를 않아서 못적었네. 모든 책이 그렇듯 시간이 지나면 기억의 풍화 때문에 내가 잘못 기억하고 있는 부분이 있을 수도 있어. 하지만 이 글의 목적이 책의 내용을 그대로 퍼오는 것은 아니니까 별로 중요하지 않은 부분이라고 생각해. 아무튼, 이 글을 읽고 코딩의 재미를 조금이라도 알게 되길 바라.
