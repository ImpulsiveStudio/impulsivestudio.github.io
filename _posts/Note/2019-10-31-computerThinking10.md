---
layout: "default"
Category: "Study"
subCat: "Note"
title: "[컴퓨터적 사고]데이터의 표현 - 2"
description: '10주차 소프트웨어적 사유 정리'
---

##### 인코딩 및 압축

인코딩이란 정보를 코드로 표현하는걸 말해.

디코딩은 그 반대로 코드로 표현된 것으로부터 정보를 추출하는 거야.

인코딩의 조건은

~~~

압축한 후의 텍스트 크기가 압축전보다 줄어들어야 한다는거야.

그리고 압축과 복원이 쉬워야 해

데이터의 손실은 무조건 없어야지.

~~~


1. Run-Length 방식 인코딩

run-length방식의 인코딩을 한번 해볼까?

run-length방식은 반복하는 부분의 길이가 같은 방식의 자료를 말해.

마치 사진같은거지.

사진은 같은 수의 픽셀이 여러번 반복되는 형태잖아?

그러니까, 6X7방식의 사진을 받는 다고 할떄


![runlength](/assets/Photo/RL.PNG)

1,2,1,3
1,1,1,4
2,5
2,5
1,3
1,4
1,5

라는 형태로 압축할 수 있다는 거지

아니면 YYYYYYBBBBBBEEEEE라는 정보가 있다고 하자.

이건 Y6B6E5로 나타낼 수 있겠지?


2. LZSS 인코딩

문제를 줄게 이걸 컴퓨터적 사고 방식으로 풀어봐

1.hand and ant

2.I love you and you love me

3.banana

이 세 문장을 압축해봐.

hand (4,3) (8,2)t

I love you and (8,3) (17,4) me

ban(2,3)

여기서 주의할 점은 공백을 잊지 말아야 한다는 점 하고,

계산을 할 때 (8,3)에서 3이 길이라는 것을 잊지 말아야 한다는거야.



![LZSS](/assets/Photo/LSS.PNG)


그런데 여기서 반복할 문자가 너무 멀리 있으면 시간이 많이 소요되겠지? 이런 문제를 방지하기 위해 Search window와 look-ahead buffer라는 것을 만들어.

search Window는 앞에서 반복할 문자가 나올 때까지의 최소대거리를 말해.

Look-ahead buffer는 앞으로 읽어들여야 할 부분의 최대 길이를 말해.



##### 전치코드

아까

AAABBCCCC를 인코딩한다고 생각해보자!

그런데, A:00 B:01 C:11이라고 한다면 어떤 문제가 생길 것 같아?

000000010111111111로 바꿨을 때 무슨 문제가 생길 것 같냐는 말이야

너무 길어

구지 모든 문자에 2비트나 부여해야 할까?

A:0 B:1 C:01로 부여해 보자

그럼, 0001101010101로 바꿀 수 있잖아? 훨씬 짧지? 그런데 이렇게 하면 문제가 생기지.

바로 0001이 AAAB인지, AAC인지 구분하지 못한다는 거야.

어떻게 이 문제를 해결할까?

첫번째 방법은 구분자를 활용하는 거야.

"/"라는 구분자를 사용해서,

0/0/0/1/1/01/01/01/01로 쓰자는 거지.

그런데 이렇게 하면 처음에 달성하려고 했던 목적인 길이의 최소화를 이루지 못해.

즉 우리는 코드의 길이가 가변적이면서도 구분자 없이 코드를 구분해 낼 수 있는 방법이 필요한거야.

이때 필요한 것이 바로 전치코드(prefix)야.

전치코드의 정의를 설명할게 조금 어려울 수 있으니까 집중해서 생각해봐.

전치코드란 한 문자의 코드가 다른 문자의 코드 앞부분이 될 수 없는 코드를 말해.

말로만 들어서는 이해가 안돼지?

예시로 설명해 줄게.

a:11, b:0, c:10으로 아무 코드나 만들어 볼게.

1101010011

위 코드에서 처음 1이 입력된 순간, 경우의 수는 a나 c 밖에 없지?

그리고 0이 입력된 순간 경우의 수는 b밖에 없을 테고 말이야.

이렇게 하면 길이가 가변적이면서도 구분자가 없이 압축을 할 수 있지.

아직도 이해가 잘 안된다면, 위에서 설정한 abc로 직접 아무 코드나 만들어 봐.

그 코드는 절대 다른 코드로 혼동되지 않을거야.

이런 코드를 만드는 알고리즘에서는 트리 구조가 사용돼.

![variable-width encoding](/assets/Photo/Tree.PNG)


그런데 이렇게 만든 전치코드를 좀 더 효율적으로 사용할 수는 없을까?

바로 가장 많이 쓰이는 문자에 가장 짧은 전치코드를 부여하는거야.

여기에 대해서 후프만이라는 사람이 좋은 생각을 해냈어.

아래는 후프만 코드를 생성하는 알고리즘이야.

>(1) 인코딩하려는 n개의 데이터에 대해 빈도수를 표시하여 n개의 노드 생성<br><br>
(2) 두 노드의 빈도수의 합이 최소가 되는 노드를 찾는다.<br><br>
(3) 두 노드를 합병시켜서 이진 트리로 만든다.<br><br>
(4) 모든 노드가 하나의 이진트리로 합쳐질 때까지 단계(2)(3)을 반복한다.

![HoffmannCode](/assets/Photo/Hoffmann.PNG)

##### 반복코드

송신자와 수신자가 정보를 받을 때, 정보가 달라질 오류를 없애기 위해 같은 정보를 3번 연속으로 보내는 코드를 반복코드라고 한다.

변조 또는 오류에서 3개의 정보를 모두 바꾸지는 않는다고 가정한다.

##### 패러티 비트

마찬가지로 송 수신자 관계에서 패러티 비트를 추가하여 짝수 홀수 맞추는거.

설명은 나중에 할게. 귀찮으니까

함튼 이건 두군데에 오류가 발생할 확률이 적다고 판단될 때만 쓸 수 있는 방법이지.

![2D parrity](/assets/Photo/2Dparrity.PNG)

![2D parrity Error](/assets/Photo/2DparrityErr.PNG)

![2D parrity Error](/assets/Photo/2DparrityErr2.PNG)


##### 바코드 체크디지트

![CheckDigit](/assets/Photo/CheckDigit.PNG)


##### 메시지 다이제스트

암호화 해시함수를 이용하는 방법이다.

체크섬을 만들듯 긴 데이터 길이의 메시지 다이제스트를 생성한다.

생성된 메시지 다이제스트를 이용하여 원래의 데이터를 재현하는 것은 거의 불가능하다.

데이터가 바뀌면 메시지 다이제스트도 바뀐다

문서의 위조 여부를 판별할 수 있다.
